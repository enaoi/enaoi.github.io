---
title: promise
date: 2019-12-19 15:40:26
categories:
- javascript
tags:
- [javascript_middle]
---

promise产生的背景和实现。

## 为什么要用Promise

javascript 是单线程语言。在ES6之前，我们使用回调函数解决异步任务。

### 异步执行

#### 回调函数

回调函数是异步编程最基本的方法  

假设f1和f2两个函数，后者必须等到前者执行完成，才能执行。

```javascript
function f1(callback){
  // do stuff
  callback();
}
//执行代码
f1(f2);
```

**优点:** 简单、容易理解和部署
**缺点:** 不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），使得程序结构混乱、流程难以追踪（尤其是回调函数嵌套的情况），而且每个任务只能指定一个回调函数。

#### 事件监听

另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。

还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。

```javascript
f1.on('done',f2);

function f1(){
  setTimeout(function(){
    f1.trigger('done');
  },1000);
}
```

上面代码中，f1.trigger('done')表示，执行完成后，立即触发done事件，从而开始执行f2。

**优点:** 比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合“（Decoupling），有利于实现模块化。

**缺点:** 整个程序都要变成事件驱动型，运行流程会变得很不清

#### 发布/订阅

"事件"完全可以理解成"信号"，如果存在一"信号中心"，某个任务执行完成，就向信号中心"发布"（publish）一个信号，其他任务可以向信号中心"订阅"（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做"发布/订阅模式"（publish-subscribe pattern）。这个模式有多种实现，下面采用的是Ben Alman的Tiny Pub/Sub。

```javascript
jQuery.subscribe("done", f2);

function f1(){
 setTimeout(function () {
  // f1的任务代码
  jQuery.publish("done");
 }, 1000);
}
```

f2完成执行后，也可以取消订阅（unsubscribe）。

```javascript
jQuery.unsubscribe("done", f2);
```

这种方法的性质与"事件监听"类似，但是明显优于后者。因为我们可以通过查看"消息中心"，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。

### 异步操作的流程控制

如果有多个异步操作，就存在一个流程控制的问题：确定操作执行的顺序，以及如何保证遵守这种顺序。

```javascript
function async(arg, callback) {
  console.log('参数为 ' + arg +' , 1秒后返回结果');
  setTimeout(function() { callback(arg * 2); }, 1000);
}
```

上面代码的async函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。

如果有6个这样的异步任务，需要全部完成后，才能执行下一步的final函数。

```javascript
function final(value) {
  console.log('完成: ', value);
}
```

请问应该如何安排操作流程？

```javascript
async(1, function(value){
  async(value, function(value){
    async(value, function(value){
      async(value, function(value){
        async(value, function(value){
          async(value, final);
        });
      });
    });
  });
});
```

上面代码采用6个回调函数的嵌套，称为"回调地狱"

#### 串行执行

我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。

```javascript
var items = [ 1, 2, 3, 4, 5, 6 ];
var results = [];
function series(item) {
  if(item) {
    async( item, function(result) {
      results.push(result);
      return series(items.shift());
    });
  } else {
    return final(results);
  }
}
series(items.shift());
```

上面代码中，函数series就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行final函数。items数组保存每一个异步任务的参数，results数组保存每一个异步任务的运行结果。

#### 并行执行

流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行final函数。

```javascript
var items = [ 1, 2, 3, 4, 5, 6 ];
var results = [];

items.forEach(function(item) {
  async(item, function(result){
    results.push(result);
    if(results.length == items.length) {
      final(results);
    }
  })
});
```

上面代码中，forEach方法会同时发起6个异步任务，等到它们全部完成以后，才会执行final函数。

并行执行的好处是效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。

#### 并行与串行的结合

所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务。这样就避免了过分占用系统资源。

```javascript
var items = [ 1, 2, 3, 4, 5, 6 ];
var results = [];
var running = 0;
var limit = 2;

function launcher() {
  while(running < limit && items.length > 0) {
    var item = items.shift();
    async(item, function(result) {
      results.push(result);
      running--;
      if(items.length > 0) {
        launcher();
      } else if(running == 0) {
        final();
      }
    });
    running++;
  }
}

launcher();
```

## Promise 对象

使用 Promise，我们可以避免"回调地狱"，使得我们的代码更加简洁 。

**Promise 的特点：**

1. 三个状态：`pending`, `fulfilled`, `rejected`。
2. 一旦状态改变，就不会再变。 `pending --> fulfilled` 或者 `pending --> rejected`。

### Promise.prototype.then

then 方法返回一个新的 Promise 实例（并不是原来的那个Promise实例），因此可以采用链式写法。

1. 只要成功或失败的回调有返回值，都会走向外层then的成功
2. reject 或 抛出异常 都会走失败
3. 就近原则捕获失败，如果没有捕获失败回调则会报错
4. 每次返回都是新的promise，原因参考1。
5. then 方法是异步的

  ```javascript
  let promise = new Promise((resolve, reject) => {
      // promise的状态是不可逆的，此处已经reject
      reject(100)
  }).then(null, (err) => {
      console.log(err)
      // 捕获错误后，返回一个数字
      return 200
  }).then((data) => {
      // 由于有返回值，进入了正常回调，说明 promise 是新创建的
      console.log(data)
  })
  ```

### Promise.prototype.catch

- Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止。
- Promise.catch 与 try/catch 的区别在于: 如果没有catch方法指定错误的回调函数，promise 对象抛出的错误不会传递到外层代码。

代码实现：

```javascript
Promise.prototype.catch(errCallback) {
    // catch 是then的简写，不处理正确回调的then方法
    return this.then(null, errCallback)
}
```

### Promise.prototype.finally

ES9 引入： 无论失败还是成功，都会执行的操作。

```javascript
Promise.prototype.finally = function(callback) {
    return this.then((data) => {
        callback()
        return data
    }, (err) => {
        callback()
        throw err
    })
}

```

### Promise.all

 1. 将多个 promsie 实例包装成新的 Promise 实例。
 2. 如果参数不是promise类型，则直接返回
 3. 如果有一个失败，则全部失败

```javascript
Promise.all([read('./name.txt'), read('./age.txt'), 3]).then((data) => {
    console.log(data)
})
// => [ 'Fiona', '12', 3 ]
```

实现代码：

```javascript
Promise.all = function (promises) {
    return new Promise((resolve, reject) => {
        let arr = []
        let count = 0
        function processData(index, value) {
            arr[index] = value;
            count++;
            if (count === promises.length) {
                resolve(arr)
            }
        }
        for (let i = 0, l = promises.length; i < l; i++) {
            let current = promises[i]
            // 判断当前是否是promise
            if (typeof current === 'object' && current !== null && current.then) {
                current.then((data) => {
                    processData(i, data)
                }, reject)
            } else {
                // 非promise 直接返回值
                processData(i, current)
            }
        }
    })
}

```

### Promise.race

```javascript
Promise.race = function (promises) {
    return new Promise((resolve, reject) => {
        for (let i = 0; i < promises.length; i++) {
            let current = promises[i]
            if (typeof current === 'object' && current !== null && current.then) {
                current.then(resolve, reject)
            } else {
                resolve(current)
            }
        }
    })
}
```

## promise/deferred 模式

promise的产生是为了解决异步回调的问题，但是如下：

```javascript
function read(url) {
    // 还是嵌套了
    return new Promise((resolve, reject) => {
        fs.readFile(url, 'utf8', function (err, data) {
            if (err) reject(err)
            resolve(data)
        })
    })
}

```

为了解决这个问题：

```javascript
Promise.deferred = Promise.defer = function () {
    let dfd = {}
    dfd.promise = new Promise((resolve, reject) => {
        dfd.resolve = resolve;
        dfd.reject = reject;
    })
    return dfd
}

```

上面的问题就可以简化为：

```javascript
// defer 版本
function read(url) {
    // 更加扁平化
    let defer = Promise.defer()
    fs.readFile(url, 'utf8', function (err, data) {
        if (err) defer.reject(err)
        defer.resolve(data)
    })
    return defer.promise
}
```

### 简写

每次需要new操作，写起来比较重复,支持功能：

```javascript
Promise.resolve(100).then()
```

代码实现很简单：

```javascript
Promise.resolve = function (val) {
    return new Promise((resolve) => {
        resolve(val)
    })
}

Promise.reject = function (err) {
    return new Promise((resolve, reject) => {
        reject(err)
    })
}
```

### promisify

bluebird 是实现和封装promise的一个重要库，它有一个非常实用的方法是promisify。nodejs 的 util 模块中也实现了 promisify 方法。

bluebird 的 promisify 方法只能针对 nodejs 的api： 

```javascript
var readFile = Promise.promisify(require("fs").readFile);
readFile("myfile.js", "utf8").then(function(contents) {
    return eval(contents);
})
```

实现方法：

```javascript
Promise.promisify = function (fn) {
    return function (...args) {
        return new Promise((resolve, reject) => {
            args.push(function (err, data) {
                if (err) reject(err)
                resolve(data)
            })
            fn.apply(null, args)
        })
    }
}
```

当这种写法也很麻烦，每一个接口都需要操作一下。nodejs中推荐使用[mz](https://github.com/normalize/mz)

## 手动实现Promise-简单版本

```javascript
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
const PENDING = 'pending'
class Promise {
    constructor(executor) {
        this.status = PENDING;
        this.value = null;
        this.reason = null;
        this.onResolveCallbacks = [];
        this.onRejectCallbacks = [];

        const resolve = (value) => {
            setTimeout(() => {
                if (this.status === PENDING) {
                    this.status = FULFILLED;
                    this.value = value;
                    this.onResolveCallbacks.forEach(fn => {
                        fn()
                    })
                }
            }, 0)
        }
        const reject = (reason) => {
            setTimeout(() => {
                if (this.status === PENDING) {
                    this.status = REJECTED;
                    this.reason = reason;
                    this.onRejectCallbacks.forEach(fn => fn())
                }
            }, 0)
        }

        try {
            executor(resolve, reject)
        } catch (error) {
            reject(error)
        }
    }

    then(onFulfilled, onRejected) {
        // then().then((data) => {// do...})  这种调用可以让data传递
        onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function (data) { return data }
        onRejected = typeof onRejected === 'function' ? onRejected : function (error) {
            throw error;
        }
        return new Promise((resolve, reject) => {
            if (this.status === FULFILLED) {
                let x = onFulfilled(this.value)
                resolve(x)
                // console.log(x)
                // setTimeout(() => {
                //     try {
                //         let x = onFulfilled(this.value)
                //         console.log(typeof x)
                //         resolve(x)
                //     } catch (error) {
                //         reject(error)
                //     }
                // }, 0)


            }
            if (this.status === REJECTED) {
                setTimeout(() => {
                    try {
                        let x = onRejected(this.reason)
                        resolve(x)
                    } catch (error) {
                        reject(error)
                    }
                }, 0)
            }
            if (this.status === PENDING) {
                this.onResolveCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            let x = onFulfilled(this.value)
                            resolve(x)
                        } catch (error) {
                            reject(error)
                        }
                    }, 0)
                })
                this.onRejectCallbacks.push(() => {
                    setTimeout(() => {
                        try {
                            let x = onRejected(this.reason)
                            resolve(x)
                        } catch (error) {
                            reject(error)
                        }
                    }, 0)
                })
            }
        })

    }

    catch(errCallback) {
        // catch 是then的简写，不处理正确回调的then方法
        return this.then(null, errCallback)
    }

    finally(callback) {
        return this.then((data) => {
            callback()
            return data
        }, (err) => {
            callback()
            throw err
        })
    }



}

Promise.all = function (promises) {
    return new Promise((resolve, reject) => {
        let arr = []
        let count = 0
        function processData(index, value) {
            arr[index] = value;
            count++;
            if (count === promises.length) {
                resolve(arr)
            }
        }
        for (let i = 0, l = promises.length; i < l; i++) {
            let current = promises[i]
            // 判断当前是否是promise
            if (typeof current === 'object' && current !== null && current.then) {
                current.then((data) => {
                    processData(i, data)
                }, reject)
            } else {
                // 非promise 直接返回值
                processData(i, current)
            }
        }
    })
}

Promise.race = function (promises) {
    return new Promise((resolve, reject) => {
        for (let i = 0; i < promises.length; i++) {
            let current = promises[i]
            if (typeof current === 'object' && current !== null && current.then) {
                current.then(resolve, reject)
            } else {
                resolve(current)
            }
        }
    })
}

Promise.deferred = Promise.defer = function () {
    let dfd = {}
    dfd.promise = new Promise((resolve, reject) => {
        dfd.resolve = resolve;
        dfd.reject = reject;
    })
    return dfd
}

Promise.resolve = function (val) {
    return new Promise((resolve) => {
        resolve(val)
    })
}

Promise.reject = function (err) {
    return new Promise((resolve, reject) => {
        reject(err)
    })
}


Promise.promisify = function (fn) {
    return function (...args) {
        return new Promise((resolve, reject) => {
            args.push(function (err, data) {
                if (err) reject(err)
                resolve(data)
            })
            fn.apply(null, args)
        })
    }

}

module.exports = Promise
```

## 参考资料

1. [promise A+规范](https://promisesaplus.com/)
2. [bluebird](http://bluebirdjs.com/docs/api/promise.promisify.html)
3. [mz](https://github.com/normalize/mz)
