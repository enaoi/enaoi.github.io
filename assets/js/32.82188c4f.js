(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{390:function(t,v,_){"use strict";_.r(v);var n=_(25),r=Object(n.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"javascript-精粹语法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#javascript-精粹语法"}},[t._v("#")]),t._v(" JavaScript 精粹语法")]),t._v(" "),_("h2",{attrs:{id:"basic"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#basic"}},[t._v("#")]),t._v(" Basic")]),t._v(" "),_("p",[_("strong",[t._v("注释:")]),t._v(" 应该使用//，避免使用/**/，因为正则表达式内可能也包含，导致注释错误。")]),t._v(" "),_("p",[_("strong",[t._v("保留字:")]),t._v(" 如 new、if、this等。但注意undefined、NaN、Infinity不在该范围内，所以对他们进行赋值操作不会报错。")]),t._v(" "),_("p",[_("strong",[t._v("标志符:")]),t._v(" 不包括保留字。应该以字符、下划线和美元符开头的一个或多个字母、数字或下划线组成。")]),t._v(" "),_("p",[_("strong",[t._v("数字:")]),t._v(" javascript 只有一个数字类型。内部被表示为64位浮点数。特殊的没有分离出整数部分，所以1和1.0的值相同。")]),t._v(" "),_("ul",[_("li",[t._v("NaN 是一个数值，NaN 不等于任何值，包括它自己，可以用函数isNaN(number)来检测。")]),t._v(" "),_("li",[t._v("javascript 内置了一个Math对象，有一套作用于数字的方法。")])]),t._v(" "),_("p",[_("strong",[t._v("字符串:")]),t._v(" javascript 创建的时候，unicode 是一个16位的字符集，所以 javascript 中的字符都是16位的。")]),t._v(" "),_("ul",[_("li",[t._v("字符串是不可变的，一旦创建，就无法改变它。但可以通过 + 运算连接其它字符串，创建一个新的字符串。")]),t._v(" "),_("li",[t._v("包含两个完全相同的字符，且字符顺序也相同的字符串被认为是相同的字符串。")])]),t._v(" "),_("p",[_("strong",[t._v("语句:")]),t._v(" 一个编译单元包含一组执行语句。")]),t._v(" "),_("p",[_("strong",[t._v("代码块:")]),t._v(" 包含在一对花括号中。原先的代码块不会创建新的作用域，但是 ES6 的 let 和 const 则会在代码块内产生作用域。")]),t._v(" "),_("p",[_("strong",[t._v("表达式:")]),t._v(" 最简单的表达式是字面量值，变量，内置的值，以new开头的调用表达式、以delete开头的属性提取表达式...")]),t._v(" "),_("p",[_("strong",[t._v("字面量:")]),t._v(" 简单创建指定规则类型的表示法。")]),t._v(" "),_("h2",{attrs:{id:"对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[t._v("#")]),t._v(" 对象")]),t._v(" "),_("p",[_("strong",[t._v("原型:")]),t._v(" 每个对象都从原型继承属性。每个对象都连接到 Object.prototype, 没有原型的对象不多，Object.prototype就是为数不多的之一，该对象的原型为null。")]),t._v(" "),_("ul",[_("li",[t._v("ES5可以使用"),_("code",[t._v("Object.getPrototypeOf(instance)")]),t._v("获得 "),_("code",[t._v("prototype")]),t._v(" 对象")]),t._v(" "),_("li",[t._v("当我们为一个对象添加属性时，这个属性就会屏蔽原型对象中的同名属性。\n"),_("strong",[t._v("原型链:")]),t._v(' 假如查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x。直到找到属性x或者原型是null的对象为止。可以看到对象的原型构成了一个"链"，通过这个链可以实现属性的继承。')])]),t._v(" "),_("h2",{attrs:{id:"函数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[t._v("#")]),t._v(" 函数")]),t._v(" "),_("p",[_("strong",[t._v("原型:")]),t._v(" 函数对象连接到 Function.prototype 对象，该对象再连接到 Object.prototype")]),t._v(" "),_("ul",[_("li",[t._v("每个函数创建时，都有两个隐藏属性：函数上下文和实现函数的行为的代码。，也产生一个prototype属性。它的值拥有一个 constructor 属性，且值为该函数的对象。")]),t._v(" "),_("li",[t._v("函数与其它对象不同之处，在于它可以被调用。")]),t._v(" "),_("li",[t._v("调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了定义时申明的形参，函数还有两个附加参数: this和arguments。\n"),_("ul",[_("li",[t._v("this 在面向对象编程中非常重要，它的值取决于调用的上下文。")]),t._v(" "),_("li",[t._v("方法调用：绑定到该对象。")]),t._v(" "),_("li",[t._v("函数调用：this绑定到全局对象。")]),t._v(" "),_("li",[t._v("构造器调用：使用关键字new来调用构造函数。调用构造函数的一个重要特征是，构造函数的prototype属性被用作新对象的原型。获取这个属性可以用[[Prototype]],某些浏览器中为 "),_("strong",[t._v("proto")])]),t._v(" "),_("li",[_("code",[t._v("call()")]),t._v("和"),_("code",[t._v("apply()")]),t._v("：call()和apply()的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内通过this来获得对它的引用。想以对象o的方法来调用函数f(),可以这样使用call()和apply()。关于bind()，它是返回一个新的函数。具体实现内部原理，后面会有代码实现。ES5中，bind()不紧是将函数绑定至一个对象，它还附带一些其它的应用：除了第一个实参外，传入bind()的实参也会绑定至this，这个附带的应用是一种常见的函数式编程技术，有时也被称为“柯里化”。")]),t._v(" "),_("li",[t._v("arguments: arguments是一个类似数组的对象。拥有一个length 属性，但不具有数组的任何方法。")])])])]),t._v(" "),_("p",[t._v("函数申明被提前到外部脚本或者是外部函数的作用域顶部。函数申明语句并非真正的语句，ECMAScript 规范只允许它们做为顶级语句。比 var 先提升。但表达式定义的函数不会提前。在定义前无法调用的。")]),t._v(" "),_("p",[t._v("return 语句导致函数会停止执行。并返回表达式给调用者，没有指定值，则返回 undefined。构造函数调用时，如果返回值不是一个对象，那么返回this。")]),t._v(" "),_("p",[t._v("嵌套函数：")]),t._v(" "),_("ul",[_("li",[t._v("被嵌套函数可以访问嵌套他们的函数的参数和变量。")]),t._v(" "),_("li",[t._v("嵌套函数不会从调用它的函数中继承 this。")])]),t._v(" "),_("p",[_("strong",[t._v("方法链:")]),t._v(" 当方法不需要返回值的时候，最好直接返回 this。如果一直在 API 开发中使用，这个 API 就可以进行链式调用。\n"),_("strong",[t._v("作用域链:")]),t._v(" 每次调用函数的时候，都会为之创建一个新的对象来保存局部变量，把这个对象添加至作用域链中。当函数返回的时候，就从作用域链中将这个绑定变量的对象删除。如果不存在嵌套的函数，也不存在其它引用指向这个绑定对象，就会被当作垃圾回收掉。如果定义了嵌套函数，每个嵌套函数都各自对应一个作用域链，并且这个作用域链指向一个变量绑定对象。但如果这些嵌套的函数对象在外部函数中保存下来了，那么他们也会和所指向的变量绑定对象一样当作垃圾回收。但如果这个函数定义了嵌套函数，并将它做为返回值返回，或者存储在某处的属性里，这时就会有一个外部引用指向这个嵌套函数。它就不会被当作垃圾回收，并且它所指向的变量绑定对象也不会被当做垃圾回收。")]),t._v(" "),_("p",[_("strong",[t._v("纯函数:")]),t._v("\n- 返回的结果只依赖它本身的arguments，输入相同的arguments永远得到相同的结果.\n- 所以Math.random()应该不算纯函数\n- 不会有调用任何网络交互\n- 不会修改传递给他们的参数\n"),_("strong",[t._v("异常:")]),t._v(" throw 语句中断函数执行。它应该抛出一个 exception 对象，包含 name 和 message 属性。\n"),_("strong",[t._v("递归:")]),t._v(" 直接或间接的调用自身的一种函数。\n"),_("strong",[t._v("作用域:")]),t._v(" javascript只有函数作用域，但块级作用域并不全面。比如var定义的变量总是全局的。\n"),_("strong",[t._v("闭包:")]),t._v(" 内部函数可以访问外部还输的参数和变量，除了this和arguments。内部函数拥有比外部函数更长的生命周期。\n"),_("strong",[t._v("回调:")]),t._v(" 传递一个函数，异步操作。\n"),_("strong",[t._v("模块:")]),t._v(" 模块利用了函数作用域和闭包来创建一般配合单例模式使用。\n"),_("strong",[t._v("级联:")]),t._v(" 方法返回this。\n"),_("strong",[t._v("科里化:")]),t._v(" 函数和参数相结合，产出一个新的函数。\n"),_("strong",[t._v("记忆:")]),t._v("  缓存曾经的结果。memoizer。")])])}),[],!1,null,null,null);v.default=r.exports}}]);