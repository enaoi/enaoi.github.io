---
title: 高性能网站建设指南
date: 2019-11-29 15:33:10
categories:
- optimization
tags:
- optimization
- tech_books
---

📚[高性能网站建设指南](https://book.douban.com/subject/3132277/)的阅读笔记

## 减少HTTP请求

### 雪碧图(CSS Sprites)

将多个图片合并为一幅单独的图片，通过`background-position`来指定偏移量，显示需要的图片。

1. 减少了请求数
2. 降低了下载数
3. 合并后的图片实际比分离的图片总和小，因为降低了图片自身的开销(颜色表，格式信息等等)

### 内联图片(Inline Images)

通过`data:URL`模式可以在Web页面中包含图片

1. 但无需任何额外的http请求。
2. base64编码会增加图片的大小，整体下载量会增加。
3. 内联在页面中的，在跨越不同页面时不会被缓存。优化的方法是使用CSS，并将内联图片作为背景。外部样式表是可以被缓存的。

## 使用内容发布网络(Content Delivery Networks)

内容发布网络(CDN) 是一组分布在多个不同地理位置的 Web 服务器，用于更加有效的向用户发布内容。

## 添加Expires头

浏览器和代理使用缓存来减少HTTP请求的数量，并减小HTTP响应的大小，使web页面加载的更快。Expires 头来告诉Web客户端它可以使用一个组件的当前副本，直到指定的时间为止。 “在这一时间后，响应被认为是无效的。”

HTTP1.1 引入 `Catch-Control` 头部来克服 `Expires` 头的限制：

1. `Expires` 头使用一个特定的时间，它要求服务器和客户端的时钟严格同步。
2. 过期日期需要经常检察，一但时间到了，需要配置另一个新的日期。

`Catch-control` 使用 `max-age` 指令指定组件被缓存多久。 它以秒为单位定义被请求时间过去的有效秒数。

🎈  `Catch-control`具有优先权。

### 缓存带来的问题是组件如何更新

> 之前有笔记专门来说这个更新机制的问题

### 4. 压缩组件(Gip Components)

通过减小响应的size来减少响应时间，对速度较慢的带宽尤为明显。

请求头中 `Accept-Encoding` 字段标识对压缩的支持。
响应头中 `Content-Encoding` 字段通知Web客户端
`Content-Encoding:gzip` 是目前最流行和有效的压缩方法。

#### 压缩什么

服务器基于文件类型选择压缩什么，但通常受限与对其进行的配置。

1. 很多网站压缩HTML文档、脚本和样式表。
2. 图片和PDF不应该被压缩，因为它们本身已经被压缩过，再进行压缩只是浪费CPU资源，还可能增加大小。

压缩通常能将数据量减少70%。

#### 代理缓存问题

代理的缓存可能是来自于不支持gzip的浏览器，于是缓存了一份非gzip的文件，此时另一个支持gzip的浏览器请求，则会返回非gzip的缓存文件。反之，情况更糟糕。

解决： 服务器响应头中增加 `Vary`字段,来告诉代理根据一个或多个请求头来改变缓存的响应。这将使得代理缓存多个版本。
设置`Vary:Accept-Encoding`代理会缓存gzip和非gzip的版本。

#### 边缘情况

无论是客户端还是服务器发声错误(发送压缩内容到不支持它的客户端，忘记将压缩内容声明为已经进行了gzip压缩等)，页面都会被破坏。

一种安全的方式，是只为了已经证实支持压缩的浏览器提供压缩内容。被称为浏览器白名单。

而代理的加入，使得情况变得更加复杂。
可以将 `User-Agent` 作为代理的另一种评判标准加到Vary头部中 `Vary:Accept-Encoding,User-Agent`。
但User-Agent种类繁多，基本上是破坏了代理缓存。

有些人采用 `Catch-Control: private` 禁止代理缓存。

## 将样式表放在顶部

样式表放在文档底部，为避免当样式变化时重绘页面中的内容，浏览器中阻止内容逐步呈现，导致白屏。

💣 样式表包含在文档中有两种方式 LINK 标签和 @import 规则：

- @import 规则必须放在所有其它规则之前，否则失效。
- @import 会导致白屏，即使放在HEAD标签中也是。

所以最好还是使用 LINK 标签

### 为什么会有白屏

> 如果样式表仍在加载，构建呈现树就是一种浪费，因为在所有样式表加载并解析拆解之前无需绘制任何东西，否则，在其准备好之前显示内容会遇到无样式内容的闪烁

## 将脚本放在底部

使用脚本时，对于所有位于脚本以下的内容，逐步呈现都被阻塞了。

### 并行下载

浏览器并行的执行HTTP请求，但过多的并行请求会影响性能。

### 脚本阻塞下载

并行下载组件的有点很明显。然而，下载脚本时并行下载实际上是被禁用的：

1. 脚本可能使用document.write 来修改页面内容，因此浏览器会等待，以确保页面能够恰当的布局。
2. 保证脚本能够按照正确的顺序执行。

现在有了更多的脚本类型 defer 和 async 带来更好的体验和优化。

## 避免CSS表达式

某些浏览器的兼容问题，可能会使得开发者用`expression` 方法调用js 表达式来完善。

不仅在页面呈现和大小改变时，页面滚动，甚至是鼠标在页面上移动，CSS表达式都会重新求值。CSS表达式的频繁求值使得其可以工作，也导致了性能低下。

解决方法：

1. 一次性表达式
    css调用该函数，函数将样式设置为一个明确的值，并移除CSS表达式。

    ```javascript
    <style>
        p{
            background-color: expression(altBgcolor(this));
        }
    <style>
    <script type="text/javascript">
    function altBgcolor(elem) {
        elem.style.backgroundColor = (new Date()).getHours()%2 ? "#F08A00":"#B88AFF";
    }
    </script>
    ```

2. 事件处理器
    监听 window.onresize 事件，通过脚本设置 CSS 属性。

## 使用外部JavaScript 和 CSS

虽然首次加载时，内联脚本和文件会因为减少了HTTP请求而获得较快的加载速度。
但外部文件的优势有：

1. 可以被浏览器缓存，一般变化的HTML不会设置为缓存对象。
2. 页面中相同的脚本和样式表，可以被复用。

## 减少DNS查找(Domain Name System)

Internet 通过IP地址来查找服务器，但由于IP地址很难记忆，通常使用包含主机名的URL来取代它。 但浏览器发送的请求，最终还是要解析 IP 地址，这就是 Domain Name System 所处的角色。

浏览器查找一个给定主机名的IP地址需要 20-120ms。 HTTP请求的响应时间依赖于DNS解析器。

DNS可以被缓存起来以提高性能：
很多浏览器拥有自己的缓存，和操作系统的缓存相分离。浏览器中其缓存中保留了DNS记录，则直接返回地址。浏览器丢弃或没有记录时，才会询问操作系统，然后操作系统通过其缓存来响应这个请求，或者将请求发送给一个远程服务器，这时就会发生潜在的速度降低。
但IP地址变化以及缓存会消耗内存，因此，应该周期性的清除缓存中的DNS记录，并配置检测清除的频率。

影响 DNS 缓存的因素：

- 服务器可以表明缓存的有效时间。查找返回的 DNS 记录包含一个存活时间(Time-to-live,TTL)值。该值告诉客户端可以对该记录缓存多久。
- 操作系统通常会考虑 TTL 值，但浏览器通常忽略该值，并设置它自己的时间设置。
- HTTP 系统中的 Keep-Alive 特性可以同时覆盖TTL和浏览器时间限制。
- 浏览器对DNS记录的数量也有限制，而不管缓存记录的时间。用户短时间内访问了多个不同域名的网站，较早的DNS记录会被丢弃。
- 但浏览器丢弃了记录，操作系统可能依然保留着该记录。

通过 Keep-Alive 和较少的域名来减少DNS查找

## 精简JavaScript(Minify JavaScript)

1. 精简脚本：移除不必要的字符以减小其大小。注释、空格、换行、制表符等都将被移除。
2. 混淆脚本和压缩等
3. 精简CSS： 合并相同类，移除不使用的类等

## 避免重定向

重定向是将用户从一个URL重新路由到另一个URL。重定向有很多种，301和302是最常见的。
当Web服务器向浏览器返回一个重定向时，响应中会拥有一个范围在3**的状态码：

- 304 Not Modified 并不是真的重定向，而是响应GET请求的缓存判断。
- 301/302 浏览器会自动将用户带到 Location 字段所给出的 URL

 缺少结尾的斜线，发生重定向是最为常见和浪费的问题。

## 移除重复脚本

## 配置ETag

多个服务器可能反而导致缓存存在问题，需要服务端进行配置。
