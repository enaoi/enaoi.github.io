(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{369:function(v,_,i){"use strict";i.r(_);var t=i(25),l=Object(t.a)({},(function(){var v=this,_=v.$createElement,i=v._self._c||_;return i("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[i("h1",{attrs:{id:"javascript-精粹语法"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#javascript-精粹语法"}},[v._v("#")]),v._v(" JavaScript 精粹语法")]),v._v(" "),i("ol",[i("li",[i("p",[v._v("注释： 应该使用//，避免使用/**/，因为正则表达式内可能也包含，导致注释错误。")])]),v._v(" "),i("li",[i("p",[v._v("保留字：如 new、if、this等。但注意undefined、NaN、Infinity不在该范围内，所以对他们进行赋值操作不会报错。")])]),v._v(" "),i("li",[i("p",[v._v("标志符：不包括保留字。应该以字符、下划线和美元符开头的一个或多个字母、数字或下划线组成。")])]),v._v(" "),i("li",[i("p",[v._v("数字： javascript 只有一个数字类型。内部被表示为64位浮点数。特殊的没有分离出整数部分，所以1和1.0的值相同。")]),v._v(" "),i("ul",[i("li",[v._v("NaN 是一个数值，NaN 不等于任何值，包括它自己，可以用函数isNaN(number)来检测。")]),v._v(" "),i("li",[v._v("javascript 内置了一个Math对象，有一套作用于数字的方法。")])])]),v._v(" "),i("li",[i("p",[v._v("字符串：javascript 创建的时候，unicode 是一个16位的字符集，所以 javascript 中的字符都是16位的。")]),v._v(" "),i("ul",[i("li",[v._v("字符串是不可变的，一旦创建，就无法改变它。但可以通过 + 运算连接其它字符串，创建一个新的字符串。")]),v._v(" "),i("li",[v._v("包含两个完全相同的字符，且字符顺序也相同的字符串被认为是相同的字符串。")])])]),v._v(" "),i("li",[i("p",[v._v("语句：一个编译单元包含一组执行语句。")])]),v._v(" "),i("li",[i("p",[v._v("代码块： 包含在一对花括号中。原先的代码块不会创建新的作用域，但是 ES6 的 let 和 const 则会在代码块内产生作用域。")])]),v._v(" "),i("li",[i("p",[v._v("表达式： 最简单的表达式是字面量值，变量，内置的值，以new开头的调用表达式、以delete开头的属性提取表达式...")])]),v._v(" "),i("li",[i("p",[v._v("字面量：简单创建指定规则类型的表示法。")])])]),v._v(" "),i("p",[v._v("对象")]),v._v(" "),i("ol",[i("li",[v._v("原型: 每个对象都从原型继承属性。每个对象都连接到 Object.prototype, 没有原型的对象不多，Object.prototype就是为数不多的之一，该对象的原型为null。\n"),i("ul",[i("li",[v._v("ES5可以使用"),i("code",[v._v("Object.getPrototypeOf(instance)")]),v._v("获得 "),i("code",[v._v("prototype")]),v._v(" 对象")])])]),v._v(" "),i("li",[v._v("当我们为一个对象添加属性时，这个属性就会屏蔽原型对象中的同名属性。")]),v._v(" "),i("li",[v._v('原型链： 假如查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x。直到找到属性x或者原型是null的对象为止。可以看到对象的原型构成了一个"链"，通过这个链可以实现属性的继承。')])]),v._v(" "),i("p",[v._v("函数")]),v._v(" "),i("ol",[i("li",[v._v("原型： 函数对象连接到 Function.prototype 对象，该对象再连接到 Object.prototype")]),v._v(" "),i("li",[v._v("每个函数创建时，都有两个隐藏属性：函数上下文和实现函数的行为的代码。，也产生一个prototype属性。它的值拥有一个 constructor 属性，且值为该函数的对象。")]),v._v(" "),i("li",[v._v("函数与其它对象不同之处，在于它可以被调用。")]),v._v(" "),i("li",[v._v("调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。除了定义时申明的形参，函数还有两个附加参数: this和arguments。\n"),i("ul",[i("li",[v._v("this 在面向对象编程中非常重要，它的值取决于调用的上下文。")]),v._v(" "),i("li",[v._v("方法调用：绑定到该对象。")]),v._v(" "),i("li",[v._v("函数调用：this绑定到全局对象。")]),v._v(" "),i("li",[v._v("构造器调用：使用关键字new来调用构造函数。调用构造函数的一个重要特征是，构造函数的prototype属性被用作新对象的原型。获取这个属性可以用[[Prototype]],某些浏览器中为 "),i("strong",[v._v("proto")])]),v._v(" "),i("li",[i("code",[v._v("call()")]),v._v("和"),i("code",[v._v("apply()")]),v._v("：call()和apply()的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内通过this来获得对它的引用。想以对象o的方法来调用函数f(),可以这样使用call()和apply()。关于bind()，它是返回一个新的函数。具体实现内部原理，后面会有代码实现。ES5中，bind()不紧是将函数绑定至一个对象，它还附带一些其它的应用：除了第一个实参外，传入bind()的实参也会绑定至this，这个附带的应用是一种常见的函数式编程技术，有时也被称为“柯里化”。")]),v._v(" "),i("li",[v._v("arguments: arguments是一个类似数组的对象。拥有一个length 属性，但不具有数组的任何方法。")])])]),v._v(" "),i("li",[v._v("函数申明被提前到外部脚本或者是外部函数的作用域顶部。函数申明语句并非真正的语句，ECMAScript 规范只允许它们做为顶级语句。比 var 先提升。但表达式定义的函数不会提前。在定义前无法调用的。")]),v._v(" "),i("li",[v._v("return 语句导致函数会停止执行。并返回表达式给调用者，没有指定值，则返回 undefined。构造函数调用时，如果返回值不是一个对象，那么返回this。")]),v._v(" "),i("li",[v._v("嵌套函数：\n"),i("ul",[i("li",[v._v("被嵌套函数可以访问嵌套他们的函数的参数和变量。")]),v._v(" "),i("li",[v._v("嵌套函数不会从调用它的函数中继承 this。")])])]),v._v(" "),i("li",[v._v("方法链： 当方法不需要返回值的时候，最好直接返回 this。如果一直在 API 开发中使用，这个 API 就可以进行链式调用。")]),v._v(" "),i("li",[v._v("作用域链：每次调用函数的时候，都会为之创建一个新的对象来保存局部变量，把这个对象添加至作用域链中。当函数返回的时候，就从作用域链中将这个绑定变量的对象删除。如果不存在嵌套的函数，也不存在其它引用指向这个绑定对象，就会被当作垃圾回收掉。如果定义了嵌套函数，每个嵌套函数都各自对应一个作用域链，并且这个作用域链指向一个变量绑定对象。但如果这些嵌套的函数对象在外部函数中保存下来了，那么他们也会和所指向的变量绑定对象一样当作垃圾回收。但如果这个函数定义了嵌套函数，并将它做为返回值返回，或者存储在某处的属性里，这时就会有一个外部引用指向这个嵌套函数。它就不会被当作垃圾回收，并且它所指向的变量绑定对象也不会被当做垃圾回收。")]),v._v(" "),i("li",[v._v("纯函数：\n"),i("ul",[i("li",[v._v("返回的结果只依赖它本身的arguments，输入相同的arguments永远得到相同的结果.")]),v._v(" "),i("li",[v._v("所以Math.random()应该不算纯函数")]),v._v(" "),i("li",[v._v("不会有调用任何网络交互")]),v._v(" "),i("li",[v._v("不会修改传递给他们的参数")])])]),v._v(" "),i("li",[v._v("异常：throw 语句中断函数执行。它应该抛出一个 exception 对象，包含 name 和 message 属性。")]),v._v(" "),i("li",[v._v("递归：直接或间接的调用自身的一种函数。")]),v._v(" "),i("li",[v._v("作用域：javascript只有函数作用域，但块级作用域并不全面。比如var定义的变量总是全局的。")]),v._v(" "),i("li",[v._v("闭包：内部函数可以访问外部还输的参数和变量，除了this和arguments。内部函数拥有比外部函数更长的生命周期。")]),v._v(" "),i("li",[v._v("回调: 传递一个函数，异步操作。")]),v._v(" "),i("li",[v._v("模块：模块利用了函数作用域和闭包来创建一般配合单例模式使用。")]),v._v(" "),i("li",[v._v("级联：方法返回this。")]),v._v(" "),i("li",[v._v("科里化：函数和参数相结合，产出一个新的函数。")]),v._v(" "),i("li",[v._v("记忆： 缓存曾经的结果。memoizer。")])])])}),[],!1,null,null,null);_.default=l.exports}}]);